#' Train prediction model for genetically regulated gene expression
#' @description This function trains a model using single-cell expression eQTL data to predict genetically regulated gene expression (GReX) from cis-SNPs. The model is based on Poisson functional linear regression and represented by a weight matrix in the output (see Details). This is the Stage-1 model of TWiST.
#' @param y Expression count data for one gene. Integer vector of length ncells (number of cells).
#' @param geno_cell Genotype of cis-SNPs of the gene. Matrix of dimensions ncells x nsnps (number of SNPs). Each row is a cell and each column is a SNP. Although SNP values are the same across cells within the same individual, they are repeated for each cell in \code{geno_cell}.
#' @param pt Pseudotime of the cells. Pseudotime values learned from packages such as Slingshot or TSCAN should be scaled to rank/(number of cells) such that values are approximately uniformly distributed between 0 and 1.
#' @param knots Internal knots for B-spline basis functions that model SNP effects on gene expression. Not including 0 and 1. Default value is \code{c(0.25,0.5,0.75)}.
#' @param degree Degree of B-spline basis functions. Default value is 3 (cubic B-spline).
#' @param lambda Tuning parameter for group lasso penalty. If null, \code{lambda} is selected by cross-validation.
#' @param nlambda Number of \code{lambda} values in cross-validation - default value is 50.
#' @param libsize Library size of the cells. Vector of length ncells.
#' @param covar Covariates to be adjusted. Matrix of ncells x (number of covariates). Not penalized.
#'
#' @return An object of class \code{grpreg} from the \code{grpreg} package, with the following additional entries:
#' \item{Wmat}{Coefficients representing effects of SNPs on gene expression. Matrix of (number of SNPs) x (number of B-spline basis functions) generated by reshaping \code{beta}. The effect of SNP k on gene expression over pseudotime t is \eqn{w_k(t)=\sum_m w_{km}\phi_m(t)}, where \eqn{w_{km}} is the \code{(k,m)} entry of \code{Wmat}.}
#' \item{knots}{Internal knots for B-spline basis functions}
#' \item{degree}{Degree of B-spline basis functions.}
#' \item{lambda.seq}{Number of \code{lambda}'s to test in cross-validation.}
#' Other entries are \code{beta}, \code{family}, \code{group}, \code{lambda}, \code{alpha}, \code{deviance}, \code{linear.predictors}, \code{n}, \code{penalty}, \code{df}, \code{iter}, \code{group.multiplier}, \code{y}. See \code{grpreg} package (https://cran.r-project.org/web/packages/grpreg/index.html) for details.
#'
#' @examples
#' library(DAESC)
#' data("example", package="DAESC")
#' res.bb <- daesc_bb(y=df$y, n=df$n, subj=df$subj, x=cbind(1,df$x), xnull=matrix(1,nrow=nrow(df),ncol=1), niter=200, niter_laplace=2, num.nodes=3,
#' optim.method="BFGS", converge_tol=1e-8)
#' str(res.bb)
#'
#' @details
#' The unique molecular identifier (UMI) count that represents gene expression (for cell j in individual) is modeled using Poisson distribution with mean \eqn{\mu_{ij}}. The mean is further modeled using a log-linear model of genetically regulated expression (GRex) and covariates:
#'
#' \deqn{\log(\mu_{ij})=c_0 + \log(\alpha_{ij}) + v_i(t_{ij}) +\gamma^T\boldsymbol{z}_{ij},}
#'
#' where \eqn{c_0} is the intercept \eqn{\alpha_{ij}} is the library size, \eqn{v_i(t_{ij})} is the GReX, and \eqn{\boldsymbol{z}_{ij}} is a vector of the covariates. The GReX is modeled using a functional linear model of cis-SNPs:
#' \eqn{v_i(t)=\sum\limits_{k} w_k(t)g_{ik}}, where \eqn{g_{ik}} is SNP k of individual i, and \eqn{w_k(t)} is a B-spline function over pseudotime t.
#'
#' A group lasso penalty is applied to induce sparsity at the SNP level, i.e., only a small number of cis-SNPs have non-zero effects on gene expression.
#'
#' @export
twist_train_model <- function(y, geno_cell, pt, knots=c(0.25,0.5,0.75), degree=3, lambda=NULL, nlambda=50, libsize=NULL, covar=NULL){

    # intercept needs to be set to TRUE to get the complete set of bases (the bases sum to 1 at each pseudotime point)
    # If intercept=FALSE, bs() will remove one basis
    ptbs <- bs(pt, knots=knots, degree=degree, intercept=TRUE, Boundary.knots=c(0,1))
    desmat <- generate_desmat(geno.temp=geno_cell, ptbs=ptbs)
    grp <- rep(1:ncol(geno_cell),each=ncol(ptbs))

    # Cross validation to select optimal lambda parameter
    if (is.null(lambda)){
        gr_cv <- cv.grpreg(X=cbind(log(libsize),covar,desmat), y=y,
                           group=c(rep(0,1+ncol(covar)), grp), penalty="grLasso",
                           family="poisson", nlambda=nlambda, alpha=0.5, nfolds=5)
        lambda.min <- gr_cv$lambda.min
    } else{
        lambda.min <- lambda
    }

    res.opt <- grpreg(X=cbind(log(libsize),covar,desmat), y=y,
                      group=c(rep(0,1+ncol(covar)), grp), penalty="grLasso",
                      family="poisson", lambda=lambda.min, alpha=0.5)
    # Different from glmnet, res.opt$beta from grpnet includes intercept
    res.opt$Wmat <- matrix(res.opt$beta[-(1:(ncol(covar)+2))], nrow=ncol(geno_cell), byrow=TRUE,
                              dimnames=list(colnames(geno_cell),paste0("bs",1:ncol(ptbs))))
    res.opt$knots <- knots
    res.opt$degree <- degree

    if (is.null(lambda)){
        res.opt$lambda.seq <- gr_cv$lambda
        res.opt$cvm <- gr_cv$cvm
    }

    return(res.opt)
}

#' Generate design matrix that combines genotypes and B-spline basis functions.
#' @param geno.temp Genotype of cis-SNPs. Matrix of ncells x (number of SNPs).
#' @param ptbs B-spline basis functions. Matrix of ncells x (number of B-spline basis functions)
generate_desmat <- function(geno.temp, ptbs){
    if (nrow(geno.temp)!=nrow(ptbs)) stop("geno.temp and ptbs should have the same number of rows.")

    desmat <- matrix(NA, nrow=nrow(geno.temp), ncol=ncol(ptbs)*ncol(geno.temp))
    for (i in 1:ncol(geno.temp)){
        desmat[,(ncol(ptbs)*(i-1)+1):(ncol(ptbs)*i)] <- ptbs*geno.temp[,i]
    }

    return(desmat)
}
